1.3. 컴퓨터과학이란?
==

컴퓨터과학은 종종 정의하기 어렵다.  
Computer science is often difficult to define. 

이것은 불행히 '컴퓨터'란 단어의 때문일 수 있다.  
This is probably due to the unfortunate use of the word “computer” in the name. 

당신이 인식하는 것처럼, 컴퓨터과학은 단순히 컴퓨터를 공부하는 것이 아니다. 비록 컴퓨터가 원리에 있어서 중요한 도움 역할을 할지라도, 그것은 단지 도구일 뿐이다.   
As you are perhaps aware, computer science is not simply the study of computers. Although computers play an important supporting role as a tool in the discipline, they are just that–tools.

컴퓨터과학은 문제, 문제해결, 문제해결과정을 통해 도출된 해결책을 공부하는 것이다.  
Computer science is the study of problems, problem-solving, and the solutions that come out of the problem-solving process.

주어진 문제, 컴퓨터과학자의 목표는 알고리즘을 개발하는 것이다. 차례차례 명령들의 리스트를. 문제들의 instance를 해결하기 위한 명령들의 리스트를 차례차례....????? 모르겠음.   
Given a problem, a computer scientist’s goal is to develop an algorithm, a step-by-step list of instructions for solving any instance of the problem that might arise. 

알고리즘은 유한한 프로세스다. 만약 따라온다면 ..?? 문제를 해결할 것이다.알고리즘은 해결책이다.  
Algorithms are finite processes that if followed will solve the problem. Algorithms are solutions.

컴퓨터과학은 알고리즘을 공부하는 것이라고 생각될 수 있다. 그러나, 우리는 조심해야만한다. 몇몇문제들은 해결책이 아닐 수도 있다는 것을.  
Computer science can be thought of as the study of algorithms. However, we must be careful to include the fact that some problems may not have a solution. 

비록 이 문장을 증명하는것이 이 텍스트의 범위를 향한다 할지라도, 몇몇 문제들은 해결되지 않을 수 있다는 것을. 컴퓨터과학을 공부한 사람들에게.  
Although proving this statement is beyond the scope of this text, the fact that some problems cannot be solved is important for those who study computer science.

우리는 충분히 컴퓨터과학을 정의할 수 있다. 그리고, 문제의 타입과 컴퓨터과학이 문제를 해결하기위한 공부일 뿐만 아니라 해결책이 없는 문제를 공부하는 것을 둘다 포함한다는 것을.   
We can fully define computer science, then, by including both types of problems and stating that computer science is the study of solutions to problems as well as the study of problems with no solutions.

매우 흔한것이다. 문제와 해결책을 묘사할 수 있을때 계산할 수 있는 단어를 포함한다는 것은. 우리는 말한다. 문제는 계산할 수 있다. 만약 그것을 풀기위한 알고리즘이 존재한다면.   
It is also very common to include the word computable when describing problems and solutions. We say that a problem is computable if an algorithm exists for solving it. 

컴퓨터과학을 대체 가능한 정의는 회자된다. 컴퓨터과학이 문제를 공부하는 것이라고. 그 문제는 계산될 수 없는 것들, 알고리즘이 존재하는 것과 존재하지 않는 것.   
An alternative definition for computer science, then, is to say that computer science is the study of problems that are and that are not computable, the study of the existence and the nonexistence of algorithms.

몇몇 케이스에선, 당신은 필기할 것이다. '컴퓨터'란 단어가 모든것에 come up 되지 않는다는 것을. 해결책은 고려된다 기계의 독립적으로.   
In any case, you will note that the word “computer” did not come up at all. Solutions are considered independent from the machine.

컴퓨터과학, 문제해결 과정을 pertains 하는것으로서, 그것은 추상회를 공부하는 것이다. 추상화는 우리가 문제와 해결책을 볼 수 있게해준다. 각각의 방법으로서. 소위 로직상 물리적인 인식으로서.      
Computer science, as it pertains to the problem-solving process itself, is also the study of abstraction. Abstraction allows us to view the problem and solution in such a way as to separate the so-called logical and physical perspectives.

기본 아이디어는 흔한 예제에 있어서 우리에게 친숙하다.  
The basic idea is familiar to us in a common example.

자동차를 고려해보라. 당신은 아마 운전해서 갈것이다. 공부하거나 일하러 오늘. 운전사, 자동차 사용자로서, 당신은 어떤 인터랙션을 가지고 있을 것이다. 그것의 목적으로서 자동차를 사용하기위해 take place in order.  
Consider the automobile that you may have driven to school or work today. As a driver, a user of the car, you have certain interactions that take place in order to utilize the car for its intended purpose.

차에타고, 키를 넣고, 자동차 시동걸고, 변속하고, 브레이크밟고, 액셀발고, 운전하기위해 steer하고. 뷰포인트의 추상화로부터, 우리는 말할 수 있다. 당신이 로지컬한 관점으로 자동차를 본다고.  
You get in, insert the key, start the car, shift, brake, accelerate, and steer in order to drive. From an abstraction point of view, we can say that you are seeing the logical perspective of the automobile. 

당신은 자동차 디자이너에 의해 제공된 함수를 사용한다. 당신을 운송할 목적으로 한 지역에서 다른곳으로. 이 함수들은 때때로 인터페이스라고 언급된다.  
You are using the functions provided by the car designers for the purpose of transporting you from one location to another. These functions are sometimes also referred to as the interface.

반면에, 기계공. 당신의 자동차를 수리해야하는 기계공은 매우 다양한 관점을 가질 수 있다. 그녀는 운전하는 법을 알 뿐만 아니라 모든 디테일을 알아야한다. carry out 하기 위해 모든 함수를. 우리가 보장받은.   
On the other hand, the mechanic who must repair your automobile takes a very different point of view. She not only knows how to drive but must know all of the details necessary to carry out all the functions that we take for granted.

그녀는 이해할 필요가 있다. 엔진이 어떻게 동작하는지, 트랜스미션이 어떻게 기어를 작동시키는지, 온도가 어떻게 컨트롤되는지, 등등. 이것은 물리적인측면으로 이해된다. 그 디테일은 'under the hood'...?   
She needs to understand how the engine works, how the transmission shifts gears, how temperature is controlled, and so on. This is known as the physical perspective, the details that take place “under the hood.”

우리가 컴퓨터를 사용할때도 마찬가지다. 대부분의 사람들은 컴퓨터를 사용한다. 문서를 쓰고, 이메일을 쓰거나 받고, 웹서핑, 음악듣기, 이미지저장하기, 게임을 하기위해. 자세한 지식이 없이. 수행하기위해 어플리케이션을 허락하기위해.  
The same thing happens when we use computers. Most people use computers to write documents, send and receive email, surf the web, play music, store images, and play games without any knowledge of the details that take place to allow those types of applications to work. 

그들은 컴퓨터를 본다. 로지컬적이거나 사용자관점에서. 컴퓨터과학자들, 프로그래머, 기술적 도우미, 시스템관리자들은 매우 다양한 컴퓨터의 관점을 갖는다.  
They view computers from a logical or user perspective. Computer scientists, programmers, technology support staff, and system administrators take a very different view of the computer.
 
그들은 알아야한다. 어떻게 운영체제가 동작하는지, 어떻게 네트워크 프로토콜이 설정되는지, 그리고 함수를 동작하기위해 어떻게 다양한 스크립트가 코딩되는지. 그들은 컴트롤되야한다. 저수준으로. 사용자의 단순한 추측으로.  
They must know the details of how operating systems work, how network protocols are configured, and how to code various scripts that control function. They must be able to control the low-level details that a user simply assumes.

흔한 점. 이 예제들 둘다. 추상화 사용자, 때떄로 클라이언트롤 불려지는, 필요하지않다. 자세한것은. 사용자는 인식한다. 인터페이스가 동작하는 방법을.  
The common point for both of these examples is that the user of the abstraction, sometimes also called the client, does not need to know the details as long as the user is aware of the way the interface works. 

이 인터페이스는 우리가 사용자로서 커뮤니케이션하는 방법이다. 구현의 복잡성을 underlyin하는것에. 또다른 추상화 예제로서, 파이썬 math 모듈을 생각해보자. 우리가 모듈을 import했을때, 우리는 계산을 수행할 수 있다. 아래와 같이    
This interface is the way we as users communicate with the underlying complexities of the implementation. As another example of abstraction, consider the Python math module. Once we import the module, we can perform computations such as

>>> import math
>>> math.sqrt(16)
4.0
>>>

이것은 추상화의 예시이다. 우리는 알필요가 업다. 어떻게 square root가 계산되는지. 그러나 우리는 안다. 그 함수가 불러지고 사용되는것을. 만약 우리가 import를 정확하게 수행한다면, 우리는 예측할 수 있다. 그 함수가 제공할 것이라고 정확한 결과를.  
This is an example of procedural abstraction. We do not necessarily know how the square root is being calculated, but we know what the function is called and how to use it. If we perform the import correctly, we can assume that the function will provide us with the correct results.
 
우리는 안다. 누군가 솔루션을 구현했다는것을. square root 문제를. 단순히 우리는 오직 그것을 어떻게 사용하는지를 알 필요가 있다. 이것은 때떄로 언급된다. "블랙박스"라고 과정의 관점에서. 우리는 단순히 인터페이스를 묘사한다: 함수의 이름, 무엇이 필요한가(파라미터), 무엇이 리턴도리 것인가. 자세한것은 감추어져있다 안쪽에.  
We know that someone implemented a solution to the square root problem but we only need to know how to use it. This is sometimes referred to as a “black box” view of a process. We simply describe the interface: the name of the function, what is needed (the parameters), and what will be returned. The details are hidden inside (see Figure 1).

